import{e as F,a as K}from"./cast-4d1aa82d.js";import{c as E}from"./ExpandedCIM-23a9d4d0.js";import"./Error-9392329b.js";import"./string-bf9c68ed.js";import{o as I,t as v,r as S,c as P,e as L}from"./typedArrayUtil-c81d173a.js";import{j as R,f as b}from"./promiseUtils-3ce2a460.js";import"./ensureType-8c80e8c7.js";import{m as A,a as x}from"./diffUtils-ba6273ab.js";import{f as O}from"./Extent-52b65909.js";import{p as U}from"./visualVariablesUtils-f202191f.js";import{S as z}from"./enums-b1d611e3.js";import{x as B,o as k,n as j,E as H,b as J}from"./Matcher-38d3d28c.js";import{p as N}from"./BaseProcessor-d2136c70.js";import"./nextTick-3ee5a785.js";import"./Color-46910694.js";import"./colorUtils-639f4d25.js";import"./mathUtils-505ef34b.js";import"./screenUtils-7afeb41c.js";import"./fieldUtils-c41301b0.js";import"./preload-helper-41c905a7.js";import"./geometry-8c15a791.js";import"./Polyline-7f90e3cc.js";import"./typeUtils-f38bdb16.js";import"./BidiEngine-836b7ef6.js";import"./aaBoundingRect-062d7c89.js";import"./jsonUtils-e2434b33.js";import"./GeometryUtils-53652037.js";import"./enums-4b2a86a0.js";import"./MaterialKey-8f458904.js";import"./definitions-19bfb61c.js";import"./mat2d-795519e1.js";import"./vec2-3a431caf.js";import"./vec2f32-eaf29605.js";import"./color-349a3ca2.js";import"./enums-64ab819c.js";import"./VertexElementDescriptor-2925c6af.js";import"./Rect-ea14f53a.js";import"./quantizationUtils-54fe414b.js";import"./floatRGBA-90587fc5.js";import"./Collection-54857936.js";import"./Evented-d69b5d66.js";import"./SimpleObservable-7e8b69a3.js";import"./visualVariablesUtils-904a1f06.js";import"./TileStrategy-cb3a7d25.js";import"./TileStore-4f504952.js";import"./Queue-4939205d.js";import"./TileKey-3acb01a1.js";import"./rbush-f2a85c98.js";import"./quickselect-56c5966e.js";import"./Query-8c2b9d22.js";import"./TimeExtent-0fb637c6.js";import"./enumeration-de0a766e.js";import"./Field-899dc481.js";import"./fieldType-68c65bf7.js";import"./Clonable-ad03ca71.js";import"./tileUtils-c2f19f52.js";import"./TurboLine-14d34b25.js";import"./assets-86d142ff.js";import"./request-16c6134d.js";import"./featureConversionUtils-93a98860.js";import"./aaBoundingBox-55a55434.js";import"./OptimizedFeature-6361f5d1.js";import"./OptimizedFeatureSet-1d1ac4b9.js";import"./defaultsJSON-b087dd4d.js";import"./GeometryUtils-dd03fc25.js";import"./earcut-61f7b102.js";import"./LRUCache-7d328c48.js";import"./MemCache-c220a92a.js";import"./devEnvironmentUtils-5002a058.js";import"./Portal-fe1a007c.js";import"./Loadable-e19fba09.js";import"./Promise-24c50191.js";import"./locale-30120714.js";import"./PortalGroup-45834c06.js";import"./PortalUser-8de15b25.js";import"./persistableUrlUtils-abff3ce1.js";import"./styleUtils-6ef1c49e.js";import"./HandleOwner-1ffa4597.js";import"./reactiveUtils-989a8d7f.js";class V{constructor(e){this._remoteClient=e,this._resourceMap=new Map,this._inFlightResourceMap=new Map,this.geometryEngine=null,this.geometryEnginePromise=null}destroy(){}async fetchResource(e,s){const r=this._resourceMap,i=r.get(e);if(i)return i;let o=this._inFlightResourceMap.get(e);if(o)return o;try{o=this._remoteClient.invoke("tileRenderer.fetchResource",{url:e},{...s}),this._inFlightResourceMap.set(e,o),o.then(a=>(this._inFlightResourceMap.delete(e),r.set(e,a),a))}catch(a){return R(a)?null:{width:0,height:0}}return o}getResource(e){return this._resourceMap.get(e)??null}}function D(t,e){return(!t.minScale||t.minScale>=e)&&(!t.maxScale||t.maxScale<=e)}function C(t){const e=t.message,s={message:{data:{},tileKey:e.tileKey,tileKeyOrigin:e.tileKeyOrigin,version:e.version},transferList:new Array};for(const r in e.data){const i=e.data[r];if(s.message.data[r]=null,S(i)){const o=i.stride,a=i.indices.slice(0),n=i.vertices.slice(0),c=i.records.slice(0),p={stride:o,indices:a,vertices:n,records:c,metrics:I(i.metrics,m=>m.slice(0))};s.transferList.push(a,n,c),s.message.data[r]=p}}return s}let w=class extends N{constructor(){super(...arguments),this.type="symbol",this._matchers={feature:null,aggregate:null},this._bufferData=new Map,this._bufferIds=new Map}initialize(){this.handles.add([this.tileStore.on("update",this.onTileUpdate.bind(this))]),this._resourceManagerProxy=new V(this.remoteClient)}destroy(){this._resourceManagerProxy.destroy()}get supportsTileUpdates(){return!0}forEachBufferId(t){this._bufferIds.forEach(e=>{e.forEach(t)})}async update(t,e){var i;const s=e.schema.processors[0];if(s.type!=="symbol")return;const r=A(this._schema,s);(x(r,"mesh")||x(r,"target"))&&(t.mesh=!0,(i=t.why)==null||i.mesh.push("Symbology changed"),this._schema=s,this._factory=this._createFactory(s),this._factory.update(s,this.tileStore.tileScheme.tileInfo))}onTileMessage(t,e,s,r){return b(r),this._onTileData(t,e,s,r)}onTileClear(t){const e={clear:!0};return this._bufferData.delete(t.key.id),this._bufferIds.delete(t.key.id),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:e})}onTileError(t,e,s){const r=s.signal,i={tileKey:t.id,error:e};return this.remoteClient.invoke("tileRenderer.onTileError",i,{signal:r})}onTileUpdate(t){for(const e of t.removed)this._bufferData.has(e.key.id)&&this._bufferData.delete(e.key.id),this._bufferIds.has(e.key.id)&&this._bufferIds.delete(e.key.id);for(const e of t.added)this._bufferData.forEach(s=>{for(const r of s)r.message.tileKey===e.id&&this._updateTileMesh("append",e,C(r),[],!1,!1,null)})}_addBufferData(t,e){var s;this._bufferData.has(t)||this._bufferData.set(t,[]),(s=this._bufferData.get(t))==null||s.push(C(e))}_createFactory(t){const{geometryType:e,objectIdField:s,fields:r}=this.service,i=(p,m)=>this.remoteClient.invoke("tileRenderer.getMaterialItems",p,m),o={geometryType:e,fields:r,spatialReference:O.fromJSON(this.spatialReference)},a=new B(i,this.tileStore.tileScheme.tileInfo),{matcher:n,aggregateMatcher:c}=t.mesh;return this._store=a,this._matchers.feature=k(n,a,o,this._resourceManagerProxy),this._matchers.aggregate=I(c,p=>k(p,a,o,this._resourceManagerProxy)),new j(e,s,a)}async _onTileData(t,e,s,r){var u;b(r);const{type:i,addOrUpdate:o,remove:a,clear:n,end:c}=e,p=!!this._schema.mesh.sortKey;if(!o){const h={type:i,addOrUpdate:null,remove:a,clear:n,end:c,sort:p};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:h},r)}const m=this._processFeatures(t,o,s,r,(u=e.status)==null?void 0:u.version);try{const h=await m;if(v(h)){const l={type:i,addOrUpdate:null,remove:a,clear:n,end:c,sort:p};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:l},r)}const d=[];for(const l of h){let f=!1;const g=l.message.bufferIds,y=t.key.id,M=l.message.tileKey;if(y!==M&&S(g)){if(!this.tileStore.get(M)){this._addBufferData(y,l),d.push(l);continue}let _=this._bufferIds.get(M);_||(_=new Set,this._bufferIds.set(M,_));const $=Array.from(g);for(const T of $){if(_.has(T)){f=!0;break}_.add(T)}}f||(this._addBufferData(y,l),d.push(l))}await Promise.all(d.map(l=>{const f=t.key.id===l.message.tileKey,g=f?e.remove:[],y=f&&e.end;return this._updateTileMesh(i,t,l,g,y,!!e.clear,r.signal)}))}catch(h){this._handleError(t,h,r)}}async _updateTileMesh(t,e,s,r,i,o,a){const n=t,c=s.message.tileKey,p=!!this._schema.mesh.sortKey;c!==e.key.id&&(i=!1);const m=I(s,l=>l.message),u=I(s,l=>l.transferList)||[],h={type:n,addOrUpdate:m,remove:r,clear:o,end:i,sort:p},d={transferList:L(u)||[],signal:a};return b(d),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:c,data:h},d)}async _processFeatures(t,e,s,r,i){if(v(e)||!e.hasFeatures)return null;const o={transform:t.transform,hasZ:!1,hasM:!1},a=this._factory,n={viewingMode:"",scale:t.scale},c=await this._matchers.feature,p=await this._matchers.aggregate;b(r);const m=this._getLabelInfos(t,e);return await a.analyze(e.getCursor(),this._resourceManagerProxy,c,p,o,n),b(r),this._writeFeatureSet(t,e,o,m,a,s,i)}_writeFeatureSet(t,e,s,r,i,o,a){const n=e.getSize(),c=this._schema.mesh.matcher.symbologyType,p=new H(t.key.id,{features:n,records:n,metrics:0},c,o,c!==z.HEATMAP,a),m={viewingMode:"",scale:t.scale},u=e.getCursor();for(;u.next();)try{const d=u.getDisplayId(),l=S(r)?r.get(d):null;i.writeCursor(p,u,s,m,t.level,l,this._resourceManagerProxy)}catch{}const h=t.tileInfoView.tileInfo.isWrappable;return p.serialize(h)}_handleError(t,e,s){if(!R(e)){const r={tileKey:t.id,error:e.message};return this.remoteClient.invoke("tileRenderer.onTileError",r,{signal:s.signal})}return Promise.resolve()}_getLabelingSchemaForScale(t){const e=this._schema.mesh.labels;if(v(e))return null;if(e.type==="subtype"){const r={type:"subtype",classes:{}};let i=!1;for(const o in e.classes){const a=e.classes[o].filter(n=>D(n,t.scale));i=i||!!a.length,r.classes[o]=a}return i?r:null}const s=e.classes.filter(r=>D(r,t.scale));return s.length?{type:"simple",classes:s}:null}_getLabels(t,e){if(e.type==="subtype"){const s=this.service.subtypeField,r=P(s,"Expected to find subtype Field"),i=t.readAttribute(r);return i==null?[]:e.classes[i]??[]}return e.classes}_getLabelInfos(t,e){const s=this._getLabelingSchemaForScale(t);if(v(s))return null;const r=new Map,i=e.getCursor();for(;i.next();){const o=i.getDisplayId(),a=[],n=U(o),c=n&&i.readAttribute("cluster_count")!==1?"aggregate":"feature",p=this._getLabels(i,s);for(const m of p){if(m.target!==c)continue;const u=i.getStorage(),h=n&&c==="feature"?u.getComputedStringAtIndex(i.readAttribute("referenceId"),m.fieldIndex):u.getComputedStringAtIndex(o,m.fieldIndex);if(!h)continue;const d=E(h.toString()),l=d[0],f=d[1];this._store.getMosaicItem(m.symbol,J(l)).then(g=>{a[m.index]={glyphs:g.glyphMosaicItems??[],rtl:f,index:m.index}})}r.set(o,a)}return r}};w=F([K("esri.views.2d.layers.features.processors.SymbolProcessor")],w);const _t=w;export{_t as default};
