import{s as W,b as _,a as B}from"./Error-9392329b.js";import{t as E,r as G}from"./typedArrayUtil-c81d173a.js";import{m as U,v as I}from"./Polyline-7f90e3cc.js";import{r as v,o as A,i as R,s as C}from"./normalizeUtilsCommon-42c6cdb7.js";import{b as T,R as M,q as H}from"./Extent-52b65909.js";import"./geometry-8c15a791.js";import{L as X,U as D}from"./request-429c0e66.js";import{c as P,v as K,d as Q}from"./jsonUtils-e2434b33.js";import{p as V}from"./string-bf9c68ed.js";function $t(t,n){return n?{...n,query:{...t??{},...n.query}}:{query:t}}function Y(t){return typeof t=="string"?X(t):V(t)}function Z(t,n,r){const s={};for(const e in t){if(e==="declaredClass")continue;const o=t[e];if(o!=null&&typeof o!="function")if(Array.isArray(o)){s[e]=[];for(let i=0;i<o.length;i++)s[e][i]=Z(o[i])}else if(typeof o=="object")if(o.toJSON){const i=o.toJSON(r&&r[e]);s[e]=n?i:JSON.stringify(i)}else s[e]=n?o:JSON.stringify(o);else s[e]=o}return s}async function tt(t,n,r,s){const e=Y(t),o=n[0].spatialReference,i={...s,query:{...e.query,f:"json",sr:JSON.stringify(o),target:JSON.stringify({geometryType:P(n[0]),geometries:n}),cutter:JSON.stringify(r)}},f=await D(e.path+"/cut",i),{cutIndexes:l,geometries:y=[]}=f.data;return{cutIndexes:l,geometries:y.map(h=>{const d=K(h);return d.spatialReference=o,d})}}function et(t){return{geometryType:P(t[0]),geometries:t.map(n=>n.toJSON())}}function nt(t,n,r){const s=Q(n);return t.map(e=>{const o=s.fromJSON(e);return o.spatialReference=r,o})}async function st(t,n,r){const s=typeof t=="string"?X(t):t,e=n[0].spatialReference,o=P(n[0]),i={...r,query:{...s.query,f:"json",sr:e.wkid?e.wkid:JSON.stringify(e),geometries:JSON.stringify(et(n))}},{data:f}=await D(s.path+"/simplify",i);return nt(f.geometries,o,e)}const F=W.getLogger("esri.geometry.support.normalizeUtils");function ot(t){return t.type==="polygon"}function rt(t){return t[0].type==="polygon"}function it(t){return t[0].type==="polyline"}function ft(t,n){if(!(t instanceof U||t instanceof I)){const e="straightLineDensify: the input geometry is neither polyline nor polygon";throw F.error(e),new B(e)}const r=A(t),s=[];for(const e of r){const o=[];s.push(o),o.push([e[0][0],e[0][1]]);for(let i=0;i<e.length-1;i++){const f=e[i][0],l=e[i][1],y=e[i+1][0],h=e[i+1][1],d=Math.sqrt((y-f)*(y-f)+(h-l)*(h-l)),a=(h-l)/d,m=(y-f)/d,p=d/n;if(p>1){for(let S=1;S<=p-1;S++){const N=S*n,c=m*N+f,u=a*N+l;o.push([c,u])}const w=(d+Math.floor(p-1)*n)/2,J=m*w+f,j=a*w+l;o.push([J,j])}o.push([y,h])}}return ot(t)?new I({rings:s,spatialReference:t.spatialReference}):new U({paths:s,spatialReference:t.spatialReference})}function z(t,n,r){if(n){const s=ft(t,1e6);t=H(s,!0)}return r&&(t=C(t,r)),t}function k(t,n,r){if(Array.isArray(t)){const s=t[0];if(s>n){const e=R(s,n);t[0]=s+e*(-2*n)}else if(s<r){const e=R(s,r);t[0]=s+e*(-2*r)}}else{const s=t.x;if(s>n){const e=R(s,n);t=t.clone().offset(e*(-2*n),0)}else if(s<r){const e=R(s,r);t=t.clone().offset(e*(-2*r),0)}}return t}function ct(t,n){let r=-1;for(let s=0;s<n.cutIndexes.length;s++){const e=n.cutIndexes[s],o=n.geometries[s],i=A(o);for(let f=0;f<i.length;f++){const l=i[f];l.some(y=>{if(y[0]<180)return!0;{let h=0;for(let a=0;a<l.length;a++){const m=l[a][0];h=m>h?m:h}h=Number(h.toFixed(9));const d=-360*R(h,180);for(let a=0;a<l.length;a++){const m=o.getPoint(f,a);o.setPoint(f,a,m.clone().offset(d,0))}return!0}})}if(e===r){if(rt(t))for(const f of A(o))t[e]=t[e].addRing(f);else if(it(t))for(const f of A(o))t[e]=t[e].addPath(f)}else r=e,t[e]=o}return t}async function ut(t,n,r){if(!Array.isArray(t))return ut([t],n);n&&typeof n!="string"&&F.warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const s=typeof n=="string"?n:(n==null?void 0:n.url)??_.geometryServiceUrl;let e,o,i,f,l,y,h,d,a=0;const m=[],p=[];for(const c of t)if(E(c))p.push(c);else if(e||(e=c.spatialReference,o=T(e),i=e.isWebMercator,y=i?102100:4326,f=v[y].maxX,l=v[y].minX,h=v[y].plus180Line,d=v[y].minus180Line),o)if(c.type==="mesh")p.push(c);else if(c.type==="point")p.push(k(c.clone(),f,l));else if(c.type==="multipoint"){const u=c.clone();u.points=u.points.map(g=>k(g,f,l)),p.push(u)}else if(c.type==="extent"){const u=c.clone()._normalize(!1,!1,o);p.push(u.rings?new I(u):u)}else if(c.extent){const u=c.extent,g=R(u.xmin,l)*(2*f);let x=g===0?c.clone():C(c.clone(),g);u.offset(g,0),u.intersects(h)&&u.xmax!==f?(a=u.xmax>a?u.xmax:a,x=z(x,i),m.push(x),p.push("cut")):u.intersects(d)&&u.xmin!==l?(a=u.xmax*(2*f)>a?u.xmax*(2*f):a,x=z(x,i,360),m.push(x),p.push("cut")):p.push(x)}else p.push(c.clone());else p.push(c);let w=R(a,f),J=-90;const j=w,S=new U;for(;w>0;){const c=360*w-180;S.addPath([[c,J],[c,-1*J]]),J*=-1,w--}if(m.length>0&&j>0){const c=ct(m,await tt(s,m,S,r)),u=[],g=[];for(let $=0;$<p.length;$++){const O=p[$];if(O!=="cut")g.push(O);else{const b=c.shift(),q=t[$];G(q)&&q.type==="polygon"&&q.rings&&q.rings.length>1&&b.rings.length>=q.rings.length?(u.push(b),g.push("simplify")):g.push(i?M(b):b)}}if(!u.length)return g;const x=await st(s,u,r),L=[];for(let $=0;$<g.length;$++){const O=g[$];O!=="simplify"?L.push(O):L.push(i?M(x.shift()):x.shift())}return L}const N=[];for(let c=0;c<p.length;c++){const u=p[c];if(u!=="cut")N.push(u);else{const g=m.shift();N.push(i===!0?M(g):g)}}return N}function wt(t,n){const r=T(n);if(r){const[s,e]=r.valid,o=e-s;if(t<s)for(;t<s;)t+=o;if(t>e)for(;t>e;)t-=o}return t}export{wt as U,Y as f,$t as i,nt as o,Z as s,ut as v};
