import{t as d}from"./typedArrayUtil-c81d173a.js";import{o as f,u as h}from"./screenUtils-7afeb41c.js";import{g as z}from"./color-349a3ca2.js";import{u as g}from"./definitions-19bfb61c.js";import{L as r}from"./enums-b1d611e3.js";import{l as S}from"./visualVariablesUtils-904a1f06.js";const $=8388607,v=8388608,E=254,x=255,L=0,m=1,y=e=>(e&v)>>>23,U=e=>e&$,R=e=>y(e)===m?E:x;function T(e){return y(e)===m}function Z(e,t){return((t?v:0)|e)>>>0}const k=(e,t)=>e&&((...s)=>t.warn("DEBUG:",...s))||(()=>null),N=!1;function O(e,t){if(!e||!t)return e;switch(t){case"radius":case"distance":return 2*e;case"diameter":case"width":return e;case"area":return Math.sqrt(e)}return e}function V(e){return{value:e.value,size:f(e.size)}}function a(e){return(e??[]).map(t=>V(t))}function u(e){if(typeof e=="string"||typeof e=="number")return f(e);const t=e;return{type:"size",expression:t.expression,stops:a(t.stops)}}const c=e=>{const t=[],s=[],n=a(e),o=n.length;for(let i=0;i<6;i++){const l=n[Math.min(i,o-1)];t.push(l.value),s.push(l.size==null?g:h(l.size))}return{values:new Float32Array(t),sizes:new Float32Array(s)}};function P(e){const t=e&&e.length>0?{}:null,s=t?{}:null;if(!t||!s)return{vvFields:t,vvRanges:s};for(const n of e)if(n.field&&(t[n.type]=n.field),n.type==="size"){s.size||(s.size={});const o=n;switch(S(o)){case r.SIZE_MINMAX_VALUE:s.size.minMaxValue={minDataValue:o.minDataValue,maxDataValue:o.maxDataValue,minSize:u(o.minSize),maxSize:u(o.maxSize)};break;case r.SIZE_SCALE_STOPS:s.size.scaleStops={stops:a(o.stops)};break;case r.SIZE_FIELD_STOPS:if(o.levels){const i={};for(const l in o.levels)i[l]=c(o.levels[l]);s.size.fieldStops={type:"level-dependent",levels:i}}else s.size.fieldStops={type:"static",...c(o.stops)};break;case r.SIZE_UNIT_VALUE:s.size.unitValue={unit:o.valueUnit,valueRepresentation:o.valueRepresentation??void 0}}}else if(n.type==="color")s.color=I(n);else if(n.type==="opacity")s.opacity=_(n);else if(n.type==="rotation"){const o=n;s.rotation={type:o.rotationType}}return{vvFields:t,vvRanges:s}}function _(e){const t={values:[0,0,0,0,0,0,0,0],opacities:[0,0,0,0,0,0,0,0]};if(typeof e.field=="string"){if(!e.stops)return null;{if(e.stops.length>8)return null;const s=e.stops;for(let n=0;n<8;++n){const o=s[Math.min(n,s.length-1)];t.values[n]=o.value,t.opacities[n]=o.opacity}}}else{if(!(e.stops&&e.stops.length>=0))return null;{const s=e.stops&&e.stops.length>=0?e.stops[0].opacity:0;for(let n=0;n<8;n++)t.values[n]=1/0,t.opacities[n]=s}}return t}function p(e,t,s){e[4*t+0]=s.r/255,e[4*t+1]=s.g/255,e[4*t+2]=s.b/255,e[4*t+3]=s.a}function I(e){if(d(e)||e.normalizationField)return null;const t={field:null,values:[0,0,0,0,0,0,0,0],colors:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]};if(typeof e.field=="string"){if(!e.stops)return null;{if(e.stops.length>8)return null;t.field=e.field;const s=e.stops;for(let n=0;n<8;++n){const o=s[Math.min(n,s.length-1)];t.values[n]=o.value,p(t.colors,n,o.color)}}}else{if(!(e.stops&&e.stops.length>=0))return null;{const s=e.stops&&e.stops.length>=0&&e.stops[0].color;for(let n=0;n<8;n++)t.values[n]=1/0,p(t.colors,n,s)}}for(let s=0;s<32;s+=4)z(t.colors,s,!0);return t}export{$ as a,P as b,m as c,y as e,U as f,R as i,N as l,k as n,T as p,O as r,Z as s,L as u};
