import{s as le,a as c}from"./Error-9392329b.js";import{h as oe}from"./string-bf9c68ed.js";import{r as b,A as ae,e as N,t as ue}from"./typedArrayUtil-c81d173a.js";import{u as G}from"./screenUtils-7afeb41c.js";import{t as de}from"./serviceCapabilitiesUtils-2296548c.js";import{m as pe}from"./diffUtils-ba6273ab.js";import{c as j}from"./labelingInfo-8ec658bf.js";import{L as O,S as y}from"./enums-b1d611e3.js";import{V as fe}from"./color-349a3ca2.js";import{c as ce}from"./utils-45a97d77.js";import{l as ye}from"./visualVariablesUtils-904a1f06.js";import{createSymbolSchema as m}from"./createSymbolSchema-8b7065b5.js";import"./ExpandedCIM-23a9d4d0.js";import"./Polyline-7f90e3cc.js";import"./mathUtils-505ef34b.js";import"./Extent-52b65909.js";import"./MaterialKey-8f458904.js";import"./mat2d-795519e1.js";import"./vec2-3a431caf.js";import"./vec2f32-eaf29605.js";import"./request-16c6134d.js";import"./Portal-fe1a007c.js";import"./persistableUrlUtils-abff3ce1.js";import"./PortalGroup-45834c06.js";import{g as Q,i as me}from"./rendererUtils-90c6d352.js";import{m as ge,d as be}from"./FeatureReductionLayer-a890a60c.js";import{e as W}from"./util-54b675a7.js";function X(e){if(!e)return O.NONE;let r=0;for(const i of e)if(i.type==="size"){const t=ye(i);r|=t,i.target==="outline"&&(r|=t<<4)}else i.type==="color"?r|=O.COLOR:i.type==="opacity"?r|=O.OPACITY:i.type==="rotation"&&(r|=O.ROTATION);return r}function xe(e,r){if(!("visualVariables"in e)||!e.hasVisualVariables("size"))return 0;const i=e.getVisualVariablesForType("size");if(!i[0])return 0;const t=i[0];if(r&&t.field==="cluster_count"&&r.type==="cluster")return r.clusterMaxSize;if(t.target==="outline")return 0;if(t.transformationType==="stops")return t.stops.map(s=>s.size).reduce(L,0);if(t.transformationType==="clamped-linear"){let s=-1/0,n=-1/0;return s=typeof t.maxSize=="number"?t.maxSize:t.maxSize.stops.map(l=>l.size).reduce(L,0),n=typeof t.minSize=="number"?t.minSize:t.minSize.stops.map(l=>l.size).reduce(L,0),Math.max(s,n)}return t.transformationType==="real-world-size"?30:void 0}function L(e,r){return Math.max(e,r)}const T=le.getLogger("esri.views.2d.layers.features.schemaUtils"),f="ValidationError";function B(e,r){let i=0,t=0,s=y.DEFAULT;if(b(e)){if(t=xe(e,r),"visualVariables"in e&&(i=X(e.visualVariables||[]),e.type==="dot-density"&&(s=y.DOT_DENSITY)),e.type==="heatmap"&&(s=y.HEATMAP),e.type==="dictionary")return{maxVVSize:t,vvFlags:i,symbologyType:y.DEFAULT};if(e.type==="pie-chart")return{maxVVSize:t,vvFlags:i,symbologyType:y.PIE_CHART};if(s!==y.DOT_DENSITY&&s!==y.HEATMAP){const n=e.getSymbols();"backgroundFillSymbol"in e&&e.backgroundFillSymbol&&n.push(e.backgroundFillSymbol);let l=!0,o=!0;for(const a of n)if(a.type==="cim"&&(o=!1),a.type==="simple-fill"||a.type==="picture-fill"){const u=a.outline,d=u&&u.style!=="none"&&u.style!=="solid",p=a.type==="simple-fill"&&a.style!=="none"&&a.style!=="solid";d&&(l=!1),(a.type==="picture-fill"||p||d)&&(o=!1)}l?s=o?y.OUTLINE_FILL_SIMPLE:y.OUTLINE_FILL:o&&(s=y.SIMPLE)}}return{vvFlags:i,maxVVSize:t,symbologyType:s}}let H=null;function ut(e){if(oe("esri-2d-update-debug")){const r=Y(e,!0);console.debug("Created new schema",r),console.debug("Schema diff",pe(H,r)),H=r}return Y(e)}function Y(e,r=!1){var i,t;try{const s=Se(e,r),n=Fe(e),l={};s.map(u=>he(l,e,u));const o=b(e.subtypeCode)?`${e.subtypeField} = ${e.subtypeCode}`:null;return{source:{definitionExpression:N(de(e.definitionExpression,o)),fields:e.fields.map(u=>u.toJSON()),gdbVersion:e.gdbVersion,historicMoment:(i=e.historicMoment)==null?void 0:i.getTime(),outFields:e.availableFields,pixelBuffer:e.pixelBuffer,spatialReference:e.spatialReference.toJSON(),timeExtent:(t=e.timeExtent)==null?void 0:t.toJSON(),customParameters:e.customParameters},attributes:{fields:{},indexCount:0},processors:s,tileRenderer:n,targets:l}}catch(s){if(s.fieldName===f)return T.error(s),null;throw s}}function he(e,r,i){switch(i.target){case"feature":return void A(e,R(r),i);case"aggregate":{if(!("featureReduction"in r))return;const t=r.featureReduction;switch(t==null?void 0:t.type){case"selection":throw new c(f,"Mapview does not support `selection` reduction type",t);case"binning":return A(e,R(r),i),void ve(e,t,r.fields.map(s=>s.toJSON()),i);case"cluster":return A(e,R(r),i),void Te(e,t,r.fields.map(s=>s.toJSON()),i)}}}}function D(e,r){var i,t;for(const s in r){const n=r[s];if(n.target!==e.name)continue;const l=e.attributes[s];if(l!=null&&l.context){const o=l.context;o.mesh=o.mesh||((i=n.context)==null?void 0:i.mesh),o.storage=o.storage||((t=n.context)==null?void 0:t.storage)}else e.attributes[s]=n}return e}function R(e){var r,i,t;return[((r=N(e.filter))==null?void 0:r.toJSON())??null,((t=N((i=N(e.featureEffect))==null?void 0:i.filter))==null?void 0:t.toJSON())??null]}function A(e,r,i){return e.feature||(e.feature={name:"feature",input:"source",filters:r,attributes:{}}),D(e.feature,i.attributes.fields),e}function Z(e,r){const{onStatisticExpression:i,onStatisticField:t,statisticType:s}=e;switch(s){case"min":case"max":case"avg":case"avg_angle":case"sum":case"count":return"esriFieldTypeDouble";case"mode":{if(i){const{returnType:l}=i;return l?l==="string"?"esriFieldTypeString":"esriFieldTypeDouble":(T.error(new c(f,"Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined",e)),"esriFieldTypeString")}const n=r.find(l=>l.name===t);return n?n.type:(T.error(new c(f,"Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined",e)),"esriFieldTypeString")}}}function ve(e,r,i,t){return e.aggregate||(e.aggregate={name:"aggregate",type:"bin",filters:null,input:"feature",params:{fixedBinLevel:r.fixedBinLevel,fields:(r.fields??[]).map(s=>({...s.toJSON(),type:Z(s,i)}))},attributes:{}}),D(e.aggregate,t.attributes.fields),e}function Te(e,r,i,t){var s;return e.aggregate||(e.aggregate={name:"aggregate",type:"cluster",input:"feature",filters:null,attributes:{},params:{clusterRadius:G(r.clusterRadius/2),clusterPixelBuffer:64*Math.ceil(G(r.clusterMaxSize)/64),fields:(s=r.fields??[])==null?void 0:s.map(n=>({...n.toJSON(),type:Z(n,i)}))}}),D(e.aggregate,t.attributes.fields),e}function x(e,r){return r.field?v(e,{...r,type:"field",field:r.field}):r.valueExpression?v(e,{...r,type:"expression",valueExpression:r.valueExpression}):{field:void 0,fieldIndex:void 0}}function v(e,r){switch(r.type){case"expression":{const i=r.valueExpression;if(!e.fields[i]){const t=e.indexCount++;e.fields[i]={...r,name:i,fieldIndex:t}}return{fieldIndex:e.fields[i].fieldIndex}}case"label-expression":{const i=JSON.stringify(r.label);if(!e.fields[i]){const t=e.indexCount++;e.fields[i]={...r,name:i,fieldIndex:t}}return{fieldIndex:e.fields[i].fieldIndex}}case"field":{const i=r.field;return r.target==="aggregate"&&e.fields[i]||(e.fields[i]={...r,name:i}),{field:i}}case"statistic":return e.fields[r.name]={...r},{field:r.name}}}function Se(e,r=!1){const i=new Array;let t=0;return i.push(Ie(e,t++,r)),i}function P(e,r,i,t,s,n=!1){const l=v(e,{type:"label-expression",target:i,context:{mesh:!0},resultType:"string",label:{labelExpression:r.labelExpression,labelExpressionInfo:r.labelExpressionInfo?{expression:r.labelExpressionInfo.expression}:null,symbol:!!r.symbol,where:r.where}}),{fieldIndex:o}=l;return{...m(r,s,n),fieldIndex:o,target:i,index:t}}function Ee(e,r,i){var d;const t="featureReduction"in r&&r.featureReduction;if(!t)return{fields:[],labels:[],matcher:void 0,rendererOverride:void 0};const s="aggregate",n=[];let l=null,o=W(r.geometryType),a=[],u=null;if(t)switch(t.type){case"selection":return T.error(new c(f,"Mapview does not support `selection` reduction type",t)),{fields:[],labels:[],matcher:void 0,rendererOverride:void 0};case"cluster":case"binning":if(n.push(...t.fields??[]),t.type==="cluster"?o="esriGeometryPoint":t.type==="binning"&&(o="esriGeometryPolygon"),t.renderer&&!((d=t.renderer.authoringInfo)!=null&&d.isAutoGenerated)){if(t.type==="cluster"){const{renderer:g}=ge(t.renderer,t,null);u=g}else u=t.renderer;const p=B(t.renderer,t);l=C(e,s,t.renderer,p,i),a=t&&t.labelsVisible&&t.labelingInfo||[]}else if(t.type==="cluster"){if(u=be(n,r.renderer,t,null,!0),t.symbol){const p=B(u,t);l={type:"simple",symbol:m(t.symbol,p,i),symbologyType:p.symbologyType}}a=t&&t.labelsVisible&&t.labelingInfo||[]}}return ze(e,n),{labels:j(a,t.type==="binning"?"esriGeometryPolygon":o),matcher:l,fields:n,rendererOverride:u}}function Ie(e,r,i=!1){var k;const t={indexCount:0,fields:{}},s="featureReduction"in e?e.featureReduction??void 0:void 0,n=s?"aggregate":"feature";if("sublayers"in e){const h={type:"subtype",subtypeField:e.subtypeField,renderers:{},symbologyType:y.DEFAULT},z={type:"subtype",mapping:{},target:"feature",subtypeField:e.subtypeField},V={type:"subtype",classes:{}},ie={type:"symbol",target:"feature",aggregateFields:[],attributes:t,storage:z,mesh:{matcher:h,aggregateMatcher:null,labels:V,sortKey:null}},J=new Set;let re=0;for(const{renderer:S,subtypeCode:E,labelingInfo:se,labelsVisible:ne}of e.sublayers){let U=0;"visualVariables"in S&&S.visualVariables&&(S.visualVariables.some(w=>w.type!=="rotation")&&T.warnOnce("SubtypeGroupLayer currently only supports rotation visualVariables. All other visualVariable types will be ignored."),U=X(S.visualVariables.filter(w=>w.type!=="size")));const _={symbologyType:y.DEFAULT,vvFlags:U,maxVVSize:0},I=C(t,n,S,_,i),F=K(t,n,S),q=ne&&se;if(I.type==="dictionary")throw new c(f,"Dictionary renderer is not supported in subtype layers");if(I.type==="subtype")throw new c(f,"Nested subtype renderers is not supported");if(b(F)&&F.type==="subtype")throw new c(f,"Nested subtype storage is not supported");if(b(F)&&b(F.attributeMapping))throw new c(f,"Non-visual-variable attributes are not supported in subtype layers");if(I.type==="heatmap")throw new c(f,"Heatmaps are not supported in subtype layers");if(I.type==="pie-chart")throw new c(f,"Pie-charts are not supported in subtype layers");if(J.has(E))throw new c(f,"Subtype codes for sublayers must be unique");J.add(E),h.renderers[E]=I,z.mapping[E]=F,q&&(V.classes[E]=q.map(w=>P(t,w,"feature",re++,_,i)))}return ie}if(((k=e.renderer)==null?void 0:k.type)==="heatmap"&&Q()==="raster"){const{radius:h,fieldOffset:z,field:V}=e.renderer;return{type:"heatmap",aggregateFields:[],attributes:t,target:n,storage:null,mesh:{radius:h,fieldOffset:z,field:x(t,{target:n,field:V,resultType:"numeric"}).field}}}const l=Ee(t,e,i),o=W(e.geometryType),a=l.rendererOverride??e.renderer,u=B(a,s),d=C(t,n,a,u,i),p=K(t,n,a),g=we(t,e.orderBy,e.renderer,s),M=e.labelsVisible&&e.labelingInfo||[],ee=j(M,o);let $=0;const te=[...ee.map(h=>P(t,h,"feature",$++,u,i)),...l.labels.map(h=>P(t,h,"aggregate",$++,u,i))];return{type:"symbol",target:n,attributes:t,aggregateFields:l.fields,storage:p,mesh:{matcher:d,labels:{type:"simple",classes:te},aggregateMatcher:l.matcher,sortKey:g}}}function Fe(e){var r;return((r=e.renderer)==null?void 0:r.type)==="heatmap"&&Q()==="raster"?{type:"heatmap"}:{type:"symbol"}}function we(e,r,i,t){if(b(t))return null;if(b(r)&&r.length){r.length>1&&T.warn(`Layer rendering currently only supports ordering by 1 orderByInfo, but found ${r.length}. All but the first will be discarded`);const s=r[0],n=s.order==="ascending"?"asc":"desc";return s.field?{field:s.field,order:n}:s.valueExpression?{fieldIndex:v(e,{type:"expression",target:"feature",valueExpression:s.valueExpression,resultType:"numeric"}).fieldIndex,order:n}:(T.error(new c(f,"Expected to find a field or valueExpression for OrderByInfo",s)),null)}return b(i)&&i.type==="unique-value"&&i.orderByClassesEnabled?{byRenderer:!0,order:"asc"}:null}function ze(e,r){const i={mesh:!0,storage:!0};for(const t of r){const{name:s,onStatisticField:n,onStatisticExpression:l,statisticType:o}=t;let a,u;const d="numeric",p="feature";l?u=v(e,{type:"expression",target:p,valueExpression:l.expression,resultType:d}).fieldIndex:a=v(e,{type:"field",target:p,field:n,resultType:d}).field,v(e,{type:"statistic",target:"aggregate",name:s,context:i,inField:a,inFieldIndex:u,statisticType:o})}}function K(e,r,i){let t;switch(i.type){case"simple":case"class-breaks":case"unique-value":case"dictionary":t={visualVariables:!0,attributes:null};break;default:t=ce(i).getStorageSpec(i)}return Ve(e,r,t,i)}function Ve(e,r,i,t){if(ue(i))return null;const{visualVariables:s,attributes:n}=i;let l=null;s&&"visualVariables"in t&&(l=Oe(e,r,t.visualVariables));const o=b(l)?4:0;let a=null;return b(n)&&(a=n.map((u,d)=>{const{field:p,fieldIndex:g}=x(e,{valueExpression:u.valueExpression,field:u.field,resultType:"numeric",target:r});return{binding:d+o,field:p,fieldIndex:g}})),{type:"simple",target:r,attributeMapping:a,vvMapping:l}}function Oe(e,r,i){if(!i||!i.length)return[];const t={storage:!0},s="numeric";return me(i).map(n=>{const l=fe(n.type),{field:o,fieldIndex:a}=x(e,{target:r,valueExpression:n.valueExpression,field:n.field,context:t,resultType:s});switch(n.type){case"size":return n.valueExpression==="$view.scale"?null:{type:"size",binding:l,field:o,fieldIndex:a,normalizationField:x(e,{target:r,field:n.normalizationField,context:t,resultType:s}).field,valueRepresentation:n.valueRepresentation??null};case"color":return{type:"color",binding:l,field:o,fieldIndex:a,normalizationField:x(e,{target:r,field:n.normalizationField,context:t,resultType:s}).field};case"opacity":return{type:"opacity",binding:l,field:o,fieldIndex:a,normalizationField:x(e,{target:r,field:n.normalizationField,context:t,resultType:s}).field};case"rotation":return{type:"rotation",binding:l,field:o,fieldIndex:a}}}).filter(b)}function C(e,r,i,t,s=!1){const n=ae(e,{indexCount:0,fields:{}});switch(i.type){case"simple":case"dot-density":return Ne(n,i,t,s);case"class-breaks":return Le(n,r,i,t,s);case"unique-value":return Re(n,r,i,t,s);case"dictionary":return Ae(n,i,t,s);case"heatmap":return Pe(n,i,t,s);case"pie-chart":return Me(n,i,t,s)}}function Ne(e,r,i,t=!1){const s=r.getSymbols(),n=s.length?s[0]:null;return{type:"simple",symbol:m(n,i,t),symbologyType:i.symbologyType}}function Me(e,r,i,t=!1){const s=r.getSymbols(),n=s[0],l=s.length>1?s[1]:null;return{type:"pie-chart",markerSymbol:m(n,i,t),fillSymbol:m(l,i,t),symbologyType:i.symbologyType}}function Le(e,r,i,t,s=!1){const n={mesh:!0,use:"renderer.field"},l=i.backgroundFillSymbol,{field:o,fieldIndex:a}=x(e,{target:r,field:i.field,valueExpression:i.valueExpression,resultType:"numeric",context:n}),u=i.normalizationType,d=u==="log"?"esriNormalizeByLog":u==="percent-of-total"?"esriNormalizeByPercentOfTotal":u==="field"?"esriNormalizeByField":null,p=i.classBreakInfos.map(g=>({symbol:m(g.symbol,t,s),min:g.minValue,max:g.maxValue})).sort((g,M)=>g.min-M.min);return{type:"interval",attributes:e.fields,field:o,fieldIndex:a,backgroundFillSymbol:m(l,t,s),defaultSymbol:m(i.defaultSymbol,t,s),intervals:p,normalizationField:i.normalizationField,normalizationTotal:i.normalizationTotal,normalizationType:d,isMaxInclusive:i.isMaxInclusive,symbologyType:t.symbologyType}}function Re(e,r,i,t,s=!1){const n=[],l=i.backgroundFillSymbol,o={target:r,context:{mesh:!0},resultType:"string"};if(i.field&&typeof i.field!="string")throw new c(f,"Expected renderer.field to be a string",i);const{field:a,fieldIndex:u}=x(e,{...o,field:i.field,valueExpression:i.valueExpression});for(const d of i.uniqueValueInfos??[])n.push({value:""+d.value,symbol:m(d.symbol,t,s)});return{type:"map",attributes:e.fields,field:a,fieldIndex:u,field2:x(e,{...o,field:i.field2}).field,field3:x(e,{...o,field:i.field3}).field,fieldDelimiter:i.fieldDelimiter??void 0,backgroundFillSymbol:m(l,t),defaultSymbol:m(i.defaultSymbol,t),map:n,symbologyType:t.symbologyType}}function Ae(e,r,i,t=!1){return{type:"dictionary",config:r.config,fieldMap:r.fieldMap,scaleExpression:r.scaleExpression,url:r.url,symbolOptions:i,symbologyType:i.symbologyType}}function Pe(e,r,i,t=!1){const s=r.getSymbols(),n=s.length?s[0]:null;return{type:"heatmap",symbol:m(n,i,t),symbologyType:i.symbologyType}}export{C as $,ut as I,B as w};
